//Input parameters:
width=40;
heigth=70;
avstand=0.3;
storrelse=10;
iso=0.3;

null=0.28;
bred=0.14;
hoyd=0.05;
tann=0.22;
detail=12;
holeradius=2;
trace=1.0;
pad=1;
xrod_distance=45; 
bearingrad=7.5;
bearinglength=45;
thickness=3;
motorpos=[0,-16.5,-12.5];
copperdistance=2.54;

$fn=detail;

    
//14 ledere som f√∏lger:

//Extrudermotor A1
//Extrudermotor A2
//Extrudermotor B1
//Extrudermotor B2

//Vifte i Front +
//Jord
//Varmeelement +    *2
//Varmeelement -    *2
//Thermistor   +
//Thermistor   -
// Z-probe  +
// Z-probe  -

ramme();
backstage();

module backstage(){
    difference(){
       union(){  
    difference(){
    color("yellow")translate([0,0])minkowski(){
      square([width-3-iso,heigth-3-iso],center=true); circle(0.5);
        }
    } 
}
translate([0,heigth*0.3]){
    minkowski(){oshw_logo_2d(21); circle(iso);}
    conn(90,21,iso);    
    conn(69,16,iso);    
    conn(-45,21,iso);   
    conn(115,16,iso);  
    conn(34,16,iso);    
    conn(45,21,iso);}
translate([0,heigth*-0.4])minkowski(){oshw_logo_2d(12);circle(iso);}

        for(l=[-1:2:1]){
    color("red")translate([11*l,heigth*0.45])circle(1.5);            
    color("red")translate([0,heigth*0.45-42.5-8])circle(1.5);   
    }
    } 
translate([0,heigth*0.3]){
    sliced(21); 
    conn(90,21,0);
    conn(115,16,0);
    conn(69,16,0); 
    conn(34,16,0);   
    conn(-45,21,0);
    conn(45,21,0);}
translate([0,heigth*-0.4])sliced(12); 
}
module conn(angle,q,isolation){intersection(){
rotate(angle)translate([-q/4*angle/abs(angle),-q/2])difference(){
    circle(q/4+trace/2+isolation);
    circle(q/4-trace/2-isolation);
}
rotate(angle)translate([0,-q/2])rotate(-angle)square(q/2+trace/2+iso,center=true);
rotate(angle)translate([0,-q*3/4])square(q/2+trace+iso,center=true);
}}
module gear_tooth_2d(d) {   polygon([[0.0,10.0*d/72.0], [0.5*d,d/15.0], 
             [0.5*d,-d/15.0], [0.0,-10.0*d/72.0]] );
}

module ramme(){
difference(){
    minkowski(){square([width-1,heigth-1],center=true); circle(0.5);}    
    minkowski(){square([width-3,heigth-3],center=true);circle(0.5);}
}
}
module oshw_logo_2d(d=10.0){   rotate(-135)
    {   difference() 
        {   union() 
            {   circle(r=14.0*d/36.0,$fn=20);
                for( a= [45: 45: 8*45] ) rotate(a) gear_tooth_2d(d);
            }
            circle(r=10.0*d/72.0,$fn=20);
            intersection() 
            {   rotate(-20) square(size=[10.0*d/18.0,10.0*d/18.0]);
                rotate(20)  square(size=[10.0*d/18.0,10.0*d/18.0]);
            }
        }
    }
}
module sliced(q){
    difference(){
    oshw_logo_2d(q);
     for(a=[-135:22.5:135]){
      for(b=[0:0.5:30]){
       rotate(a)translate([cos(b*40),b*q/21])rotate(sin(b*40)*30)square([iso,0.6*q/12],center=true);   
      }
     }   
    }
}
    module trixter (startcompx,startcompy,srotation,spinx,spiny,starttype,startdivider,startpad,endcompx,endcompy,erotation,epinx,epiny,endtype,enddivider,endpad,room){
           difference(){
track(startcompx,startcompy,srotation,spinx,spiny,starttype,startdivider,startpad,endcompx,endcompy,erotation,epinx,epiny,endtype,enddivider,endpad,1);
     track(startcompx,startcompy,srotation,spinx,spiny,starttype,startdivider,startpad,endcompx,endcompy,erotation,epinx,epiny,endtype,enddivider,endpad,0);          
  //    echo (fpName,"[0][0],");
               
   }
    }
    module track (startcompx,startcompy,srotation,spinx,spiny,starttype,startdivider,startpad,endcompx,endcompy,erotation,epinx,epiny,endtype,enddivider,endpad,room) {
    //debug points Startpoints are red, Endpoints are green
    color("red")translate([startcompx,startcompy])rotate(srotation)translate([spinx,spiny])circle(0.2);    
    color("green")translate([endcompx,endcompy])rotate(erotation)translate([epinx,epiny])circle(0.2);   
    
    startradius=sqrt(spinx*spinx+spiny*spiny);
    startisahead=(spinx/(abs(spinx)));
    endradius=sqrt(epinx*epinx+epiny*epiny);
    endisup=(epiny/(abs(epiny)));
    endisahead=(epinx/(abs(epinx)));
    
    oldangle=[90-startisahead*-asin(spinx/startradius),
    90+(epinx/abs(epinx))*asin(epinx/endradius)];
    newangle=[oldangle[0]+srotation*endisup,
    oldangle[1]+erotation*endisahead*-endisup];
    
    coords=[ [startradius*cos(newangle[0])*-startisahead, startradius*sin(newangle[0])*(spiny/(abs(spiny)))],[endradius*sin(-90-newangle[1])*endisahead,endradius*sin(newangle[1])*endisup] ];
    
    startx=startcompx+coords[0][0];
    starty=startcompy+coords[0][1];
    endx=endcompx+coords[1][0];
    endy=endcompy+coords[1][1];
   
    startendx=startx+(endx-startx)*abs(room-0.5);
    startendy=starty+(endy-starty)*abs(room-0.5);
    incrementxs=(startendx-startx)/(startdivider);
    incrementys=(startendy-starty)/(startdivider);
    incrementxe=(endx-startendx)/(enddivider);
    incrementye=(endy-startendy)/(enddivider);
    
    midpoint=[startendx,startendy];
    curve=(startdivider);
    pointsstart = [
[startx,starty],
[startx+1*incrementxs,starty+1*incrementys],[startx+2*incrementxs,starty+2*incrementys],
[startx+3*incrementxs,starty+3*incrementys],[startx+4*incrementxs,starty+4*incrementys],
[startx+5*incrementxs,starty+5*incrementys],[startx+6*incrementxs,starty+6*incrementys],
[startx+7*incrementxs,starty+7*incrementys],[startx+8*incrementxs,starty+8*incrementys],
[startx+9*incrementxs,starty+9*incrementys],[startx+10*incrementxs,starty+10*incrementys],
[startx+11*incrementxs,starty+11*incrementys],[startx+12*incrementxs,starty+12*incrementys],
[startx+13*incrementxs,starty+13*incrementys],[startendx,startendy]];
    pointsend = [
//[startendx,startendy],
midpoint,
[startendx+1*incrementxe,startendy+1*incrementye], 
[startendx+2*incrementxe,startendy+2*incrementye], 
[startendx+3*incrementxe,startendy+3*incrementye],
[startendx+4*incrementxe,startendy+4*incrementye],
[startendx+5*incrementxe,startendy+5*incrementye],
[startendx+6*incrementxe,startendy+6*incrementye],
[startendx+7*incrementxe,startendy+7*incrementye],
[startendx+8*incrementxe,startendy+8*incrementye],
[startendx+9*incrementxe,startendy+9*incrementye],
[startendx+10*incrementxe,startendy+10*incrementye],
[startendx+11*incrementxe,startendy+11*incrementye],
[startendx+12*incrementxe,startendy+12*incrementye],
[startendx+13*incrementxe,startendy+13*incrementye],
[endx,endy]];
    
    pointsHcurvestart = [
[startx,starty],
[startx+1*incrementxs,starty+1*incrementys+startdivider*0.2*sin(1*90/(startdivider/2))],
[startx+2*incrementxs,starty+2*incrementys-startdivider*0.2*sin(2*90/(startdivider/2))],
[startx+3*incrementxs,starty+3*incrementys-startdivider*0.2*sin(3*90/(startdivider/2))],
[startx+4*incrementxs,starty+4*incrementys-startdivider*0.2*sin(4*90/(startdivider/2))],
[startx+5*incrementxs,starty+5*incrementys-startdivider*0.2*sin(5*90/(startdivider/2))],
[startx+6*incrementxs,starty+6*incrementys-startdivider*0.2*sin(6*90/(startdivider/2))],
[startx+7*incrementxs,starty+7*incrementys-startdivider*0.2*sin(7*90/(startdivider/2))],
[startx+8*incrementxs,starty+8*incrementys-startdivider*0.2*sin(8*90/(startdivider/2))],
[startx+9*incrementxs,starty+9*incrementys-startdivider*0.2*sin(9*90/(startdivider/2))],
[startx+10*incrementxs,starty+10*incrementys-startdivider*0.2*sin(10*90/(startdivider/2))],
[startx+11*incrementxs,starty+11*incrementys-startdivider*0.2*sin(11*90/(startdivider/2))],
[startx+12*incrementxs,starty+12*incrementys-startdivider*0.2*sin(12*90/(startdivider/2))],
[startx+13*incrementxs,starty+13*incrementys-startdivider*0.2*sin(13*90/(startdivider/2))],
[startendx,startendy]];
    
    pointsHcurveend = [
[startendx,startendy],
[startendx+1*incrementxe+enddivider*0.2*sin(1*90/(enddivider/2)),startendy+1*incrementye], 
[startendx+2*incrementxe+enddivider*0.2*sin(2*90/(enddivider/2)),startendy+2*incrementye], 
[startendx+3*incrementxe+enddivider*0.2*sin(3*90/(enddivider/2)),startendy+3*incrementye],
[startendx+4*incrementxe+enddivider*0.2*sin(4*90/(enddivider/2)),startendy+4*incrementye],
[startendx+5*incrementxe+enddivider*0.2*sin(5*90/(enddivider/2)),startendy+5*incrementye],
[startendx+6*incrementxe+enddivider*0.2*sin(6*90/(enddivider/2)),startendy+6*incrementye],
[startendx+7*incrementxe+enddivider*0.2*sin(7*90/(enddivider/2)),startendy+7*incrementye],
[startendx+8*incrementxe+enddivider*0.2*sin(8*90/(enddivider/2)),startendy+8*incrementye],
[startendx+9*incrementxe+enddivider*0.2*sin(9*90/(enddivider/2)),startendy+9*incrementye],
[startendx+10*incrementxe+enddivider*0.2*sin(10*90/(enddivider/2)),startendy+10*incrementye],
[startendx+11*incrementxe+enddivider*0.2*sin(11*90/(enddivider/2)),startendy+11*incrementye],
[startendx+12*incrementxe+enddivider*0.2*sin(12*90/(enddivider/2)),startendy+12*incrementye],
[startendx+13*incrementxe+enddivider*0.2*sin(13*90/(enddivider/2)),startendy+13*incrementye],
[endx,endy]];
    
    pointsVcurvestart = [
[startx,starty],
[startx+1*incrementxs+startdivider*0.2*sin(1*90/(startdivider/2)),starty+1*incrementys],
[startx+2*incrementxs+startdivider*0.2*sin(2*90/(startdivider/2)),starty+2*incrementys],
[startx+3*incrementxs+startdivider*0.2*sin(3*90/(startdivider/2)),starty+3*incrementys],
[startx+4*incrementxs+startdivider*0.2*sin(4*90/(startdivider/2)),starty+4*incrementys],
[startx+5*incrementxs-startdivider*0.2*sin(5*90/(startdivider/2)),starty+5*incrementys],
[startx+6*incrementxs-startdivider*0.2*sin(6*90/(startdivider/2)),starty+6*incrementys],
[startx+7*incrementxs-startdivider*0.2*sin(7*90/(startdivider/2)),starty+7*incrementys],
[startx+8*incrementxs-startdivider*0.2*sin(8*90/(startdivider/2)),starty+8*incrementys],
[startx+9*incrementxs-startdivider*0.2*sin(9*90/(startdivider/2)),starty+9*incrementys],
[startx+10*incrementxs-startdivider*0.2*sin(10*90/(startdivider/2)),starty+10*incrementys],
[startx+11*incrementxs-startdivider*0.2*sin(11*90/(startdivider/2)),starty+11*incrementys],
[startx+12*incrementxs-startdivider*0.2*sin(12*90/(startdivider/2)),starty+12*incrementys],
[startx+13*incrementxs-startdivider*0.2*sin(13*90/(startdivider/2)),starty+13*incrementys],
[startendx,startendy]];
    
    pointsVcurveend = [[startendx,startendy],
[startendx+1*incrementxe-enddivider*0.2*sin(1*90/(enddivider/2)),startendy+1*incrementye], 
[startendx+2*incrementxe-enddivider*0.2*sin(2*90/(enddivider/2)),startendy+2*incrementye], 
[startendx+3*incrementxe-enddivider*0.2*sin(3*90/(enddivider/2)),startendy+3*incrementye],
[startendx+4*incrementxe-enddivider*0.2*sin(4*90/(enddivider/2)),startendy+4*incrementye],
[startendx+5*incrementxe-enddivider*0.2*sin(5*90/(enddivider/2)),startendy+5*incrementye],
[startendx+6*incrementxe-enddivider*0.2*sin(6*90/(enddivider/2)),startendy+6*incrementye],
[startendx+7*incrementxe-enddivider*0.2*sin(7*90/(enddivider/2)),startendy+7*incrementye],
[startendx+8*incrementxe-enddivider*0.2*sin(8*90/(enddivider/2)),startendy+8*incrementye],
[startendx+9*incrementxe-enddivider*0.2*sin(9*90/(enddivider/2)),startendy+9*incrementye],
[startendx+10*incrementxe-enddivider*0.2*sin(10*90/(enddivider/2)),startendy+10*incrementye],
[startendx+11*incrementxe-enddivider*0.2*sin(11*90/(enddivider/2)),startendy+11*incrementye],
[startendx+12*incrementxe-enddivider*0.2*sin(12*90/(enddivider/2)),startendy+12*incrementye],
[startendx+13*incrementxe-enddivider*0.2*sin(13*90/(enddivider/2)),startendy+13*incrementye],
[endx,endy]];

//Straight line vectors
    for (k=[1:1:startdivider]){
            if (starttype==0){
                updowntest1=pointsstart[k][1]-pointsstart[k-1][1];
                updownvector1=(updowntest1/(abs(updowntest1)));
                rightlefttest1=pointsstart[k][0]-pointsstart[k-1][0];
                rightleftvector1=(rightlefttest1/(abs(rightlefttest1)));
            translate([pointsstart[k][0]+(pointsstart[k-1][0]-pointsstart[k][0])/2,pointsstart[k][1]+(pointsstart[k-1][1]-pointsstart[k][1])/2])rotate(
                90+updownvector1*asin((pointsstart[k-1][0]-pointsstart[k][0])/sqrt((pointsstart[k-1][0]-pointsstart[k][0])*(pointsstart[k-1][0]-pointsstart[k][0])+(pointsstart[k-1][1]-pointsstart[k][1])*(pointsstart[k-1][1]-pointsstart[k][1])))                -90-rightleftvector1*acos((pointsstart[k-1][0]-pointsstart[k][0])/sqrt((pointsstart[k-1][0]-pointsstart[k][0])*(pointsstart[k-1][0]-pointsstart[k][0])+(pointsstart[k-1][1]-pointsstart[k][1])*(pointsstart[k-1][1]-pointsstart[k][1])))
                )square([sqrt((pointsstart[k-1][0]-pointsstart[k][0])*(pointsstart[k-1][0]-pointsstart[k][0])+(pointsstart[k-1][1]-pointsstart[k][1])*(pointsstart[k-1][1]-pointsstart[k][1])),trace+round(room)*iso],center=true);
            
        }           
            }
    for (l=[1:1:enddivider-1]){
            if (endtype==0){
                updowntest2=pointsend[l][1]-pointsend[l-1][1];
                updownvector2=(updowntest2/(abs(updowntest2)));
                rightlefttest2=pointsstart[l][0]-pointsstart[l-1][0];
                rightleftvector2=(rightlefttest2/(abs(rightlefttest2)));
               translate([pointsend[l][0]+(pointsend[l-1][0]-pointsend[l][0])/2,pointsend[l][1]+(pointsend[l-1][1]-pointsend[l][1])/2])rotate(
                90+updownvector2*asin((pointsend[l-1][0]-pointsend[l][0])/sqrt((pointsend[l-1][0]-pointsend[l][0])*(pointsend[l-1][0]-pointsend[l][0])+(pointsend[l-1][1]-pointsend[l][1])*(pointsend[l-1][1]-pointsend[l][1])))
                )square([sqrt((pointsend[l-1][0]-pointsend[l][0])*(pointsend[l-1][0]-pointsend[l][0])+(pointsend[l-1][1]-pointsend[l][1])*(pointsend[l-1][1]-pointsend[l][1])),trace+round(room)*iso],center=true);
          
         if(l==enddivider-1) {
             updowntest5=endy-pointsHcurveend[l][1];
             rightlefttest3=pointsstart[l][0]-pointsstart[l-1][0];
             rightleftvector3=(rightlefttest3/(abs(rightlefttest3)));
             translate([endx+(pointsend[l-1][0]-endx)/2,endy+(pointsend[l-1][1]-endy)/2])rotate(90+updownvector2*asin((pointsend[l-1][0]-endx)/sqrt((pointsend[l-1][0]-endx)*(pointsend[l-1][0]-endx)+(pointsend[l-1][1]-endy)*(pointsend[l-1][1]-endy))))square([sqrt((pointsend[l-1][0]-endx)*(pointsend[l-1][0]-endx)+(pointsend[l-1][1]-endy)*(pointsend[l-1][1]-endy)),trace+iso],center=true);
       
        }  }       
            }  
       
//Horisontal sine curve vectors
       for (q=[1:1:startdivider]){
            if (starttype==1){
                updowntest3=pointsHcurvestart[q][1]-pointsHcurvestart[q-1][1];
                translate([pointsHcurvestart[q][0]+(pointsHcurvestart[q-1][0]-pointsHcurvestart[q][0])/2,pointsHcurvestart[q][1]+(pointsHcurvestart[q-1][1]-pointsHcurvestart[q][1])/2])rotate(90+(updowntest3/(abs(updowntest3)))*asin((pointsHcurvestart[q-1][0]-pointsHcurvestart[q][0])/sqrt((pointsHcurvestart[q-1][0]-pointsHcurvestart[q][0])*(pointsHcurvestart[q-1][0]-pointsHcurvestart[q][0])+(pointsHcurvestart[q-1][1]-pointsHcurvestart[q][1])*(pointsHcurvestart[q-1][1]-pointsHcurvestart[q][1]))))square([sqrt((pointsHcurvestart[q-1][0]-pointsHcurvestart[q][0])*(pointsHcurvestart[q-1][0]-pointsHcurvestart[q][0])+(pointsHcurvestart[q-1][1]-pointsHcurvestart[q][1])*(pointsHcurvestart[q-1][1]-pointsHcurvestart[q][1]))+iso,trace+round(room)*iso],center=true);
             }             
    }
 for (r=[1:1:enddivider-1]){
            if (endtype==1){
                updowntest3=pointsHcurveend[r][1]-pointsHcurveend[r-1][1];
                translate([pointsHcurveend[r][0]+(pointsHcurveend[r-1][0]-pointsHcurveend[r][0])/2,pointsHcurveend[r][1]+(pointsHcurveend[r-1][1]-pointsHcurveend[r][1])/2])rotate(90+(updowntest3/(abs(updowntest3)))*asin((pointsHcurveend[r-1][0]-pointsHcurveend[r][0])/sqrt((pointsHcurveend[r-1][0]-pointsHcurveend[r][0])*(pointsHcurveend[r-1][0]-pointsHcurveend[r][0])+(pointsHcurveend[r-1][1]-pointsHcurveend[r][1])*(pointsHcurveend[r-1][1]-pointsHcurveend[r][1]))))square([sqrt((pointsHcurveend[r-1][0]-pointsHcurveend[r][0])*(pointsHcurveend[r-1][0]-pointsHcurveend[r][0])+(pointsHcurveend[r-1][1]-pointsHcurveend[r][1])*(pointsHcurveend[r-1][1]-pointsHcurveend[r][1]))+iso,trace+round(room)*iso],center=true);
                
                 if(r==enddivider-1) {
                     updowntest6=endy-pointsHcurveend[r][1];
                 
                 translate([endx+(pointsHcurveend[r][0]-endx)/2,endy+(pointsHcurveend[r][1]-endy)/2])rotate(90+(updowntest6/(abs(updowntest6)))*asin((pointsHcurveend[r][0]-endx)/sqrt((pointsHcurveend[r][0]-endx)*(pointsHcurveend[r][0]-endx)+(pointsHcurveend[r][1]-endy)*(pointsHcurveend[r][1]-endy))))square([sqrt((pointsHcurveend[r][0]-endx)*(pointsHcurveend[r][0]-endx)+(pointsHcurveend[r][1]-endy)*(pointsHcurveend[r][1]-endy))+iso,trace+round(room)*iso],center=true);          
                        }
              }
    }     
 
//Vertical sine curve vectors       
for (q=[1:1:startdivider]){
            if (starttype==2){
                updowntest3=pointsVcurvestart[q][1]-pointsVcurvestart[q-1][1];
                translate([pointsVcurvestart[q][0]+(pointsVcurvestart[q-1][0]-pointsVcurvestart[q][0])/2,pointsVcurvestart[q][1]+(pointsVcurvestart[q-1][1]-pointsVcurvestart[q][1])/2])rotate(90+(updowntest3/(abs(updowntest3)))*asin((pointsVcurvestart[q-1][0]-pointsVcurvestart[q][0])/sqrt((pointsVcurvestart[q-1][0]-pointsVcurvestart[q][0])*(pointsVcurvestart[q-1][0]-pointsVcurvestart[q][0])+(pointsVcurvestart[q-1][1]-pointsVcurvestart[q][1])*(pointsVcurvestart[q-1][1]-pointsVcurvestart[q][1]))))square([sqrt((pointsVcurvestart[q-1][0]-pointsVcurvestart[q][0])*(pointsVcurvestart[q-1][0]-pointsVcurvestart[q][0])+(pointsVcurvestart[q-1][1]-pointsVcurvestart[q][1])*(pointsVcurvestart[q-1][1]-pointsVcurvestart[q][1]))+iso,trace+round(room)*iso],center=true);
             }             
    }
 for (r=[1:1:enddivider-1]){
            if (endtype==2){
                updowntest4=pointsVcurveend[r][1]-pointsVcurveend[r-1][1];
                translate([pointsVcurveend[r][0]+(pointsVcurveend[r-1][0]-pointsVcurveend[r][0])/2,pointsVcurveend[r][1]+(pointsVcurveend[r-1][1]-pointsVcurveend[r][1])/2])rotate(90+(updowntest4/(abs(updowntest4)))*asin((pointsVcurveend[r-1][0]-pointsVcurveend[r][0])/sqrt((pointsVcurveend[r-1][0]-pointsVcurveend[r][0])*(pointsVcurveend[r-1][0]-pointsVcurveend[r][0])+(pointsVcurveend[r-1][1]-pointsVcurveend[r][1])*(pointsVcurveend[r-1][1]-pointsVcurveend[r][1]))))square([sqrt((pointsVcurveend[r-1][0]-pointsVcurveend[r][0])*(pointsVcurveend[r-1][0]-pointsVcurveend[r][0])+(pointsVcurveend[r-1][1]-pointsVcurveend[r][1])*(pointsVcurveend[r-1][1]-pointsVcurveend[r][1]))+iso,trace+round(room)*iso],center=true);
                
                 if(r==enddivider-1) {
                 updowntest7=endy-pointsVcurveend[r][1];
                 translate([endx+(pointsVcurveend[r][0]-endx)/2,endy+(pointsVcurveend[r][1]-endy)/2])rotate(90+(updowntest7/(abs(updowntest7)))*asin((pointsVcurveend[r][0]-endx)/sqrt((pointsVcurveend[r][0]-endx)*(pointsVcurveend[r][0]-endx)+(pointsVcurveend[r][1]-endy)*(pointsVcurveend[r][1]-endy))))square([sqrt((pointsVcurveend[r][0]-endx)*(pointsVcurveend[r][0]-endx)+(pointsVcurveend[r][1]-endy)*(pointsVcurveend[r][1]-endy))+iso,trace+round(room)*iso],center=true);          
                        }
              }
    }      

//(startcompx, startcompy, startcomprotation, startx, starty, starttype, startdivider, startpad, endcompx, endcompy, endcomprotation, endx, endy, endtype,enddivider,endpad,round(room))
difference(){
     union(){
         translate([0,0]){
if (startpad==1)translate([startx,starty])rotate(360/(4*detail))circle(pad+iso*round(room), $fn=detail);
if (startpad==2)translate([startx,starty])rotate(360/(4*detail))circle(pad*0.75+iso*round(room), $fn=detail);
if (startpad==4)translate([startx,starty])rotate(-9)intersection(){
    translate([pad/3,0])square([pad,2*pad],center=true);
    translate([-pad/3,0])rotate(360/(4*detail))circle(pad*0.75+iso*round(room), $fn=detail);
}
if (startpad==5)translate([startx,starty])rotate(-9)intersection(){
    translate([-pad/3,0])square([pad,2*pad],center=true);
    translate([pad/3,0])rotate(360/(4*detail))circle(pad*0.75+iso*round(room), $fn=detail);
}
    if (startpad==3)translate([startx,starty])rotate(360/(4*detail)){
        for (s=[360/(2*detail):360/detail:360+360/detail])rotate(s)square([pad*0.60+iso,trace],center=false);
            circle(pad*0.75+iso*round(room), $fn=detail);
            }
if (endpad==1)translate([endx,endy])rotate(360/(4*detail))circle(pad+iso*round(room), $fn=detail);
if (endpad==2)translate([endx,endy])rotate(360/(4*detail))circle(pad*0.75+iso*round(room), $fn=detail);
if (endpad==4)translate([endx,endy])rotate(-9)intersection(){
    translate([pad/2,0])square([pad,2*pad],center=true);
    rotate(360/(4*detail))circle(pad*0.75+iso*round(room), $fn=detail);
}
if (endpad==5)translate([endx,endy])rotate(-9)intersection(){
    translate([-pad/2,0])square([pad,2*pad],center=true);
    rotate(360/(4*detail))circle(pad*0.75+iso*round(room), $fn=detail);
}    
if (endpad==3)translate([endx,endy])rotate(360/(4*detail)){
        for (t=[360/(2*detail):360/detail:360+360/detail])rotate([0,0,t])square([pad*0.60+iso,trace],center=false);
            circle(pad*0.75+iso*round(room), $fn=detail);
            }
       }
if (startpad==0)translate([startx,starty])circle(trace/2+iso*round(room));
if (endpad==0)translate([endx,endy])circle(trace/2+iso*round(room));
    }
if (startpad==1)translate([startx,starty])rotate(360/(4*detail))circle(holeradius);
if (endpad==1) translate([endx,endy])rotate(360/(4*detail))circle(holeradius );
if (startpad==2)translate([startx,starty])rotate(360/(4*detail))circle(holeradius);
if (endpad==2) translate([endx,endy])rotate(360/(4*detail))circle(holeradius);
if (endpad==4) translate([endx,endy])rotate(360/(4*detail))circle(holeradius); 
if (endpad==5) translate([endx,endy])rotate(360/(4*detail))circle(holeradius);   
   }        
    }
